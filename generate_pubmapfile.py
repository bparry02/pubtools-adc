#!/usr/bin/env python3
#
# Generated by Claude 4 Sonnet
#
"""
Transform clouds.json to pub-mapfile format

This script reads a clouds.json file and filters images that contain
"us-east-1-hourly" in their "dest" attribute. It then transforms these
images to match the pub-mapfile JSON structure and outputs them to multiple
timestamped files for three different regions: us-east-1, us-iso-east-1, and us-isob-east-1.

For each region, it creates two files:
- pub-mapfile-<timestamp>.json (main version)
- test-pub-mapfile-<timestamp>.json (test version with empty billing codes)

Files are organized in the directory structure: {output-dir}/{errata}/{region}/

The script uses boto3 to describe AMIs and extract boot_mode information.
AWS credentials must be configured (via AWS CLI, environment variables,
or IAM roles) with permissions to describe EC2 images. Any AWS API errors
will display helpful error messages and exit gracefully.

Requirements:
    - boto3 (pip install boto3)
    - AWS credentials configured
    - EC2:DescribeImages permission

Usage:
    python3 generate_pubmapfile.py --clouds-json-file <file> [--output-dir OUTPUT_DIR]
    or
    ./generate_pubmapfile.py --clouds-json-file <file> [--output-dir OUTPUT_DIR]

Examples:
    python3 generate_pubmapfile.py --clouds-json-file stage/clouds.json
    # Creates files in: ./dist/pub-mapfile/{errata}/{region}/

    python3 generate_pubmapfile.py --clouds-json-file stage/clouds.json --output-dir /tmp/myfiles
    # Creates files in: /tmp/myfiles/{errata}/{region}/

    ./generate_pubmapfile.py --clouds-json-file /path/to/clouds.json --output-dir ./output
    # Creates files in: ./output/{errata}/{region}/
"""

import argparse
import json
import os
import sys
from datetime import datetime
import boto3
from botocore.exceptions import ClientError, BotoCoreError
import copy
from cloudimg.aws import AWSBootMode



def get_ami_boot_mode(image_id, region='us-east-1'):
    """
    Describe an AMI using boto3 and return the AWSBootMode enum name.

    Args:
        image_id (str): The AMI ID to describe
        region (str): AWS region where the AMI is located

    Returns:
        str: The AWSBootMode enum name ('uefi', 'legacy', 'hybrid', or 'not_set')

    Note:
        If any AWS API errors occur, the script will print an informational
        message and exit gracefully.
    """
    try:
        # Create EC2 client for the specified region
        ec2_client = boto3.client('ec2', region_name=region)

        # Describe the AMI
        response = ec2_client.describe_images(ImageIds=[image_id])

        if response['Images']:
            image_info = response['Images'][0]
            boot_mode_enum = AWSBootMode(image_info.get('BootMode'))
            return boot_mode_enum.name
        else:
            print(f"Error: No AMI found with ID {image_id} in region {region}")
            print("Please verify the AMI ID and region are correct.")
            sys.exit(1)

    except ClientError as e:
        error_code = e.response['Error']['Code']
        if error_code == 'InvalidAMIID.NotFound':
            print(f"Error: AMI {image_id} not found in region {region}")
            print("Please verify the AMI ID exists in the specified region.")
        elif error_code == 'UnauthorizedOperation':
            print(f"Error: Not authorized to describe AMI {image_id} in region {region}")
            print("Please check your AWS credentials and permissions (EC2:DescribeImages required).")
        else:
            print(f"Error: AWS API error describing AMI {image_id}: {e}")
            print("Please check your AWS configuration and try again.")
        sys.exit(1)

    except Exception as e:
        print(f"Error: Unexpected error describing AMI {image_id}: {e}")
        print("Please check your AWS configuration, credentials, and network connectivity.")
        sys.exit(1)

def transform_image_to_pubmapfile_format(image):
    """
    Transform a clouds.json image to pub-mapfile format.
    """
    # Convert from absolute path to relative path format expected by pub-mapfile
    src_filename = os.path.basename(image.get('src'))
    # NOTE: image files are expected to be staged before running pubtools-adc-push
    # A stage directory with AWS_IMAGES directory is required by pubtool-adc-push
    relative_path = f"stage/{image.get('region')}/AWS_IMAGES/{src_filename}"

    boot_mode = get_ami_boot_mode(image.get('image_id'),
                                  image.get('region'))

    # Create the transformed image object
    transformed = {
        "attributes": {
            "billing_codes": image.get('billing_codes'),
            "boot_mode": boot_mode,
            "description": image.get('description'),
            "ena_support": image.get('ena_support', True),
            "public_image": False,           # commercial images imported into ADC regions should never be public; they must be customized first
            "region": image.get('region', 'us-east-1'),
            "release": image.get('release', {}),
            "root_device": image.get('root_device', ''),
            "sriov_net_support": image.get('sriov_net_support', ''),
            "type": image.get('type', 'hourly'),
            "virtualization": image.get('virtualization', ''),
            "volume": image.get('volume', '')
        },
        "filename": image.get('name', ''),   # NOTE: for reference only, image name is dynamically generated by pubtool-adc
        # TODO: only sha256sum is supported
        # "md5sum": image.get('md5sum', ''),
        "version": image.get('origin', ''),
        "relative_path": relative_path
    }

    return transformed

def main():
    # Parse command-line arguments
    parser = argparse.ArgumentParser(
        description='Transform clouds.json to pub-mapfile format',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --clouds-json-file stage/clouds.json
  %(prog)s --clouds-json-file stage/clouds.json --output-dir /tmp
  %(prog)s --clouds-json-file /path/to/clouds.json --output-dir ./output

Output files will be created in: {output-dir}/{errata}/{region}/
        """
    )
    parser.add_argument('--clouds-json-file', '-c',
                        help='Path to the clouds.json file to process',
                        required=True)
    parser.add_argument('--output-dir', '-o',
                        help='Base directory for output files. Files will be written to {output-dir}/{errata}/{region}/ (default: ./dist/pub-mapfile)',
                        default='./dist/pub-mapfile')

    args = parser.parse_args()

    # Read clouds.json
    try:
        with open(args.clouds_json_file, 'r') as f:
            clouds_data = json.load(f)
    except FileNotFoundError:
        print(f"Error: {args.clouds_json_file} not found")
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON from {args.clouds_json_file}: {e}")
        sys.exit(1)

    # Select images that contain "us-east-1-hourly" in dest attribute
    # and exclude SAP images
    filtered_images = [
        image for image in clouds_data
        if (
            (
                (isinstance(image.get('dest', []), list) and 'us-east-1-hourly' in image.get('dest', [])) or
                (isinstance(image.get('dest', []), str) and image.get('dest', []) == 'us-east-1-hourly')
            )
            and image.get('build_info', {}).get('name', '') != 'rhel-sap-ec2'
        )
    ]

    print(f"Found {len(filtered_images)} images with 'us-east-1-hourly' in dest attribute (excluding SAP)")

    if not filtered_images:
        print("Error:No images found matching the filter criteria. Exiting.")
        sys.exit(1)

    # Transform images to pub-mapfile format
    transformed_files = []
    for image in filtered_images:
        transformed = transform_image_to_pubmapfile_format(image)
        transformed_files.append(transformed)

    # Create the pub-mapfile structure
    pub_mapfile = {
        "header": {
            "version": "0.2"
        },
        "payload": {
            "files": transformed_files
        }
    }

    # Get errata from first filtered image for directory structure
    errata = filtered_images[0].get('origin', 'unknown_errata').replace(':', '_')
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

    # Define the three regions to generate files for
    regions = ["us-east-1", "us-iso-east-1", "us-isob-east-1"]

    # Generate files for each region
    for region in regions:
        # Create region-specific versions of the data
        region_pub_mapfile = copy.deepcopy(pub_mapfile)
        region_test_pub_mapfile = copy.deepcopy(pub_mapfile)

        # Update region in all file entries
        for file_entry in region_pub_mapfile['payload']['files']:
            file_entry['attributes']['region'] = region

        for file_entry in region_test_pub_mapfile['payload']['files']:
            file_entry['attributes']['region'] = region
            file_entry['attributes']['billing_codes'] = {
                "codes": [],
                "name": "HourlyTest"
            }

        # Create directory structure: {output-dir}/{errata}/{region}
        region_output_dir = os.path.join(args.output_dir, errata, region)
        if not os.path.exists(region_output_dir):
            os.makedirs(region_output_dir)

        # Generate filenames
        output_filename = f"pub-mapfile-{timestamp}.json"
        test_output_filename = f"test-pub-mapfile-{timestamp}.json"

        output_path = os.path.join(region_output_dir, output_filename)
        test_output_path = os.path.join(region_output_dir, test_output_filename)

        # Write both output files for this region
        try:
            # Write main pub-mapfile
            with open(output_path, 'w') as f:
                json.dump(region_pub_mapfile, f, indent=2)
            print(f"Successfully created {output_path} with {len(transformed_files)} image files")

            # Write test pub-mapfile
            with open(test_output_path, 'w') as f:
                json.dump(region_test_pub_mapfile, f, indent=2)
            print(f"Successfully created {test_output_path} with {len(transformed_files)} image files (test version)")

        except Exception as e:
            print(f"Error writing output files for region {region}: {e}")
            continue

if __name__ == "__main__":
    main()